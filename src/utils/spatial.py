import pandas as pd
import math
from shapely.geometry import Polygon, MultiPolygon, LineString, Point
from shapely.ops import unary_union, polygonize
import geopandas as gpd
from sklearn.cluster import DBSCAN
from pyproj import Transformer
import numpy as np
from collections import defaultdict

def create_tree_polygons(tree_data: list[dict], epsg: int = 32734) -> list:
    df = pd.DataFrame(tree_data)

    gdf = gpd.GeoDataFrame(
        df, geometry=gpd.points_from_xy(df["lng"], df["lat"]), crs="EPSG:4326"
    )
    gdf_metric = gdf.to_crs(epsg=epsg)

    def buffer_from_area(area):
        return math.sqrt(area / math.pi)

    gdf_metric["geometry"] = gdf_metric.apply(
        lambda row: row.geometry.buffer(buffer_from_area(row["area"])), axis=1
    )

    # print("Buffered geometries in metric CRS:")
    # print(gdf_metric["geometry"])
    # print("Buffered areas in m² (metric CRS):", gdf_metric["geometry"].area)

    gdf = gdf_metric.to_crs("EPSG:4326")

    return list(gdf["geometry"])


# def find_missing_tree_gaps(outer_polygon, tree_polygons, min_gap_area=5.0, epsg=32734):
    gdf_outer = gpd.GeoSeries([outer_polygon], crs="EPSG:4326").to_crs(epsg=epsg)
    outer_proj = gdf_outer.iloc[0]

    gdf_trees = gpd.GeoSeries(tree_polygons, crs="EPSG:4326").to_crs(epsg=epsg)
    trees_proj = gdf_trees.unary_union

    outer_boundary = outer_proj.boundary
    tree_boundaries = [poly.boundary for poly in gdf_trees]

    # Combine boundaries into one MultiLineString
    combined_boundaries = unary_union([outer_boundary] + tree_boundaries)

    # Generate polygons from the combined boundaries
    possible_polygons = list(polygonize(combined_boundaries))

    # Filter polygons:
    # - inside outer polygon
    # - do not intersect any tree polygon (gaps)
    gap_polygons = []
    for poly in possible_polygons:
        if outer_proj.contains(poly):
            if not trees_proj.intersects(poly):
                if poly.area > min_gap_area:
                    gap_polygons.append(poly)

    print(f"Total polygons generated by polygonize: {len(possible_polygons)}")
    print(f"Outer polygon area (m²): {outer_proj.area}")
    print(f"Trees union area (m²): {trees_proj.area}")
    print(f"Number of gap polygons > {min_gap_area} m²: {len(gap_polygons)}")
    print(f"Total gap area (m²): {sum(g.area for g in gap_polygons)}")
    for i, gap in enumerate(gap_polygons):
        print(f"Gap {i} area (m²): {gap.area}")

    # Return gaps reprojected back to lat/lng
    gdf_gaps = gpd.GeoSeries(gap_polygons, crs=f"EPSG:{epsg}").to_crs(epsg=4326)
    return list(gdf_gaps)

def reproject_gaps_to_latlng(gap_polygons_proj):
    gdf = gpd.GeoDataFrame(geometry=gap_polygons_proj, crs="EPSG:32734")
    gdf_latlng = gdf.to_crs(epsg=4326)
    return list(gdf_latlng.geometry)

def create_missing_tree_polygons(
    missing_coords: list[dict],
    placeholder_area_m2: float = 1.0,
    epsg_metric: int = 32734,
) -> list:
    def buffer_radius(area):
        return math.sqrt(area / math.pi)

    # Create Point geometries from dicts: Point(longitude, latitude)
    df = gpd.GeoDataFrame(
        geometry=[Point(coord["lng"], coord["lat"]) for coord in missing_coords],
        crs="EPSG:4326"
    )
    df_metric = df.to_crs(epsg=epsg_metric)

    radius = buffer_radius(placeholder_area_m2)
    df_metric["geometry"] = df_metric["geometry"].buffer(radius)

    df_latlng = df_metric.to_crs("EPSG:4326")
    return list(df_latlng.geometry)

def find_missing_tree_positions(tree_data: list[dict], outer_polygon,
                               epsg_metric: int = 32734,
                               row_spacing: float = 6.1,
                               tree_spacing: float = 3.0,
                               tolerance: float = 4.5) -> dict:
    
    tree_df = pd.DataFrame(tree_data)
    tree_gdf = gpd.GeoDataFrame(tree_df,
                                geometry=gpd.points_from_xy(tree_df["lng"], tree_df["lat"]),
                                crs="EPSG:4326")
    
    print(f"Total input trees: {len(tree_gdf)}")  # DEBUG

    
    tree_gdf_proj = tree_gdf.to_crs(epsg=epsg_metric)
    outer_proj = gpd.GeoSeries([outer_polygon], crs="EPSG:4326").to_crs(epsg=epsg_metric).iloc[0]
    
    # 2. Analyze existing tree pattern to infer grid orientation
    grid_angle, actual_row_spacing = analyze_tree_pattern(tree_gdf_proj)
    
    # 3. Generate expected grid based on inferred pattern
    expected_positions = generate_expected_grid(outer_proj, tree_gdf_proj, 
                                              grid_angle, actual_row_spacing, tree_spacing)
    
    print(f"Expected grid positions: {len(expected_positions)}")  # DEBUG

    # 4. Match existing trees to expected positions
    matched_trees, unmatched_expected = match_trees_to_grid(tree_gdf_proj, expected_positions, tolerance)
    print(f"Successfully matched trees: {len(matched_trees)}")  # DEBUG
    print(f"Unmatched expected positions: {len(unmatched_expected)}")  # DEBUG
    
    # 5. Identify missing positions
    missing_positions = identify_missing_trees(unmatched_expected, outer_proj)
    
    return format_results(matched_trees, missing_positions, epsg_metric)


def analyze_tree_pattern(tree_gdf_proj):
    """Analyze existing trees to determine grid orientation and spacing."""
    coords = [(pt.x, pt.y) for pt in tree_gdf_proj.geometry]
        
    # Cluster by Y coordinate to find rows
    y_coords = np.array([[pt[1]] for pt in coords])
    row_clusters = DBSCAN(eps=3.0, min_samples=2).fit(y_coords)
    
    # Calculate actual row spacing from clusters
    unique_labels = set(row_clusters.labels_) - {-1}
    if len(unique_labels) < 2:
        return 0, 6.5  # Default if can't determine
    
    row_centers = []
    for label in unique_labels:
        mask = row_clusters.labels_ == label
        row_y = np.mean([coords[i][1] for i in range(len(coords)) if mask[i]])
        row_centers.append(row_y)
    
    row_centers.sort()
    actual_spacing = np.mean(np.diff(row_centers)) if len(row_centers) > 1 else 6.5
    
    # Determine grid angle (0 for horizontal rows, could be extended for angled orchards)
    grid_angle = 0  # Simplified for now
    
    return grid_angle, actual_spacing

def generate_expected_grid(outer_polygon, existing_trees, grid_angle, row_spacing, tree_spacing):
    """Generate all expected tree positions based on inferred pattern."""
    minx, miny, maxx, maxy = outer_polygon.bounds
    
    expected_positions = []
    
    # Generate grid points
    y = miny + row_spacing/2  # Start with half spacing from edge
    while y < maxy:
        x = minx + tree_spacing/2  # Start with half spacing from edge
        while x < maxx:
            point = Point(x, y)
            # Only include if point is within orchard boundary
            if outer_polygon.contains(point) or outer_polygon.touches(point):
                expected_positions.append({
                    'geometry': point,
                    'x': x,
                    'y': y,
                    'expected_row': int((y - miny) / row_spacing) + 1,
                    'expected_col': int((x - minx) / tree_spacing) + 1
                })
            x += tree_spacing
        y += row_spacing
    
    return expected_positions

def match_trees_to_grid(existing_trees, expected_positions, tolerance):
    """Match existing trees to expected grid positions."""
    matched = []
    unmatched_expected = expected_positions.copy()
    
    for _, tree in existing_trees.iterrows():
        tree_point = tree.geometry
        best_match = None
        min_distance = float('inf')
        
        for i, expected in enumerate(unmatched_expected):
            distance = tree_point.distance(expected['geometry'])
            if distance < tolerance and distance < min_distance:
                min_distance = distance
                best_match = i
        
        if best_match is not None:
            expected_pos = unmatched_expected.pop(best_match)
            matched.append({
                'tree_index': tree.name,
                'geometry': tree.geometry,
                'expected_geometry': expected_pos['geometry'],
                'row': expected_pos['expected_row'],
                'col': expected_pos['expected_col'],
                'distance_from_expected': min_distance
            })
    
    return matched, unmatched_expected

def identify_missing_trees(unmatched_expected, outer_polygon):
    """Filter unmatched positions to identify likely missing trees."""
    missing = []
    
    for pos in unmatched_expected:
        # Additional validation - ensure position is well within orchard
        # (not too close to edges where trees might legitimately be absent)
        buffer_distance = 3.0  # meters
        if outer_polygon.buffer(-buffer_distance).contains(pos['geometry']):
            missing.append(pos)
    
    return missing

def format_results(matched_trees, missing_positions, epsg_metric):
    """Format results for visualization with confidence scoring."""
    
    # Convert matched trees back to WGS84
    labeled_tree_coords = []
    tree_points = []
    
    for match in matched_trees:
        point_wgs = gpd.GeoSeries([match['geometry']], crs=epsg_metric).to_crs("EPSG:4326").iloc[0]
        
        labeled_tree_coords.append({
            "lat": point_wgs.y,
            "lng": point_wgs.x,
            "label": f"{match['row']}.{match['col']}"
        })
        
        tree_points.append(Point(point_wgs.x, point_wgs.y))
    
    # Convert missing positions with confidence scoring
    missing_coords = []
    for pos in missing_positions:
        point_wgs = gpd.GeoSeries([pos['geometry']], crs=epsg_metric).to_crs("EPSG:4326").iloc[0]
        
        # Simple confidence based on position within orchard
        # You can enhance this with more sophisticated logic
        confidence = "high"  # Default
        
        missing_coords.append({
            "lat": point_wgs.y,
            "lng": point_wgs.x,
            "row": pos['expected_row'],
            "col": pos['expected_col'],
            "confidence": confidence
        })
    
    return {
        "missing_coords": missing_coords,
        "labeled_tree_coords": labeled_tree_coords,
        "tree_points": tree_points,
        "matched_trees": matched_trees
    }