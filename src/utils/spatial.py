import pandas as pd
import math
from shapely.geometry import Polygon, MultiPolygon, LineString
from shapely.ops import unary_union, polygonize
import geopandas as gpd

def create_tree_polygons(tree_data: list[dict], epsg: int = 32734) -> list:
    df = pd.DataFrame(tree_data)

    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df["lng"], df["lat"]), crs="EPSG:4326")
    gdf_metric = gdf.to_crs(epsg=epsg)

    def buffer_from_area(area):
        return math.sqrt(area / math.pi)

    gdf_metric["geometry"] = gdf_metric.apply(
        lambda row: row.geometry.buffer(buffer_from_area(row["area"])),
        axis=1
    )

    # print("Buffered geometries in metric CRS:")
    # print(gdf_metric["geometry"])
    # print("Buffered areas in m² (metric CRS):", gdf_metric["geometry"].area)

    gdf = gdf_metric.to_crs("EPSG:4326")
  
    return list(gdf["geometry"])

def find_missing_tree_gaps(outer_polygon, tree_polygons, min_gap_area=5.0, epsg=32734):
    gdf_outer = gpd.GeoSeries([outer_polygon], crs="EPSG:4326").to_crs(epsg=epsg)
    outer_proj = gdf_outer.iloc[0]

    gdf_trees = gpd.GeoSeries(tree_polygons, crs="EPSG:4326").to_crs(epsg=epsg)
    trees_proj = gdf_trees.unary_union

    # Extract boundaries
    outer_boundary = outer_proj.boundary
    tree_boundaries = [poly.boundary for poly in gdf_trees]

    # Combine boundaries into one MultiLineString
    combined_boundaries = unary_union([outer_boundary] + tree_boundaries)

    # Generate polygons from the combined boundaries
    possible_polygons = list(polygonize(combined_boundaries))

    # Filter polygons:
    # - inside outer polygon
    # - do not intersect any tree polygon (gaps)
    gap_polygons = []
    for poly in possible_polygons:
        if outer_proj.contains(poly):
            if not trees_proj.intersects(poly):
                if poly.area > min_gap_area:
                    gap_polygons.append(poly)

    print(f"Total polygons generated by polygonize: {len(possible_polygons)}")
    print(f"Outer polygon area (m²): {outer_proj.area}")
    print(f"Trees union area (m²): {trees_proj.area}")
    print(f"Number of gap polygons > {min_gap_area} m²: {len(gap_polygons)}")
    print(f"Total gap area (m²): {sum(g.area for g in gap_polygons)}")
    for i, gap in enumerate(gap_polygons):
        print(f"Gap {i} area (m²): {gap.area}")
    

    # Return gaps reprojected back to lat/lng
    gdf_gaps = gpd.GeoSeries(gap_polygons, crs=f"EPSG:{epsg}").to_crs(epsg=4326)
    return list(gdf_gaps)


def reproject_gaps_to_latlng(gap_polygons_proj):
    gdf = gpd.GeoDataFrame(geometry=gap_polygons_proj, crs="EPSG:32734")
    gdf_latlng = gdf.to_crs(epsg=4326)
    return list(gdf_latlng.geometry)