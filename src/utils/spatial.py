import pandas as pd
import math
from shapely.geometry import Polygon, MultiPolygon, LineString, Point
from shapely.ops import unary_union, polygonize
import geopandas as gpd
from sklearn.cluster import DBSCAN
from pyproj import Transformer
import numpy as np
from collections import defaultdict
from scipy.spatial.distance import pdist
from scipy.spatial import Voronoi


def create_tree_polygons(tree_data: list[dict], epsg: int = 32734) -> list:
    df = pd.DataFrame(tree_data)

    gdf = gpd.GeoDataFrame(
        df, geometry=gpd.points_from_xy(df["lng"], df["lat"]), crs="EPSG:4326"
    )
    gdf_metric = gdf.to_crs(epsg=epsg)

    def buffer_from_area(area):
        return math.sqrt(area / math.pi)

    gdf_metric["geometry"] = gdf_metric.apply(
        lambda row: row.geometry.buffer(buffer_from_area(row["area"])), axis=1
    )

    # print("Buffered geometries in metric CRS:")
    # print(gdf_metric["geometry"])
    # print("Buffered areas in m² (metric CRS):", gdf_metric["geometry"].area)

    gdf = gdf_metric.to_crs("EPSG:4326")

    return list(gdf["geometry"])

    # def find_missing_tree_gaps(outer_polygon, tree_polygons, min_gap_area=5.0, epsg=32734):
    gdf_outer = gpd.GeoSeries([outer_polygon], crs="EPSG:4326").to_crs(epsg=epsg)
    outer_proj = gdf_outer.iloc[0]

    gdf_trees = gpd.GeoSeries(tree_polygons, crs="EPSG:4326").to_crs(epsg=epsg)
    trees_proj = gdf_trees.unary_union

    outer_boundary = outer_proj.boundary
    tree_boundaries = [poly.boundary for poly in gdf_trees]

    # Combine boundaries into one MultiLineString
    combined_boundaries = unary_union([outer_boundary] + tree_boundaries)

    # Generate polygons from the combined boundaries
    possible_polygons = list(polygonize(combined_boundaries))

    # Filter polygons:
    # - inside outer polygon
    # - do not intersect any tree polygon (gaps)
    gap_polygons = []
    for poly in possible_polygons:
        if outer_proj.contains(poly):
            if not trees_proj.intersects(poly):
                if poly.area > min_gap_area:
                    gap_polygons.append(poly)

    print(f"Total polygons generated by polygonize: {len(possible_polygons)}")
    print(f"Outer polygon area (m²): {outer_proj.area}")
    print(f"Trees union area (m²): {trees_proj.area}")
    print(f"Number of gap polygons > {min_gap_area} m²: {len(gap_polygons)}")
    print(f"Total gap area (m²): {sum(g.area for g in gap_polygons)}")
    for i, gap in enumerate(gap_polygons):
        print(f"Gap {i} area (m²): {gap.area}")

    # Return gaps reprojected back to lat/lng
    gdf_gaps = gpd.GeoSeries(gap_polygons, crs=f"EPSG:{epsg}").to_crs(epsg=4326)
    return list(gdf_gaps)


def reproject_gaps_to_latlng(gap_polygons_proj):
    gdf = gpd.GeoDataFrame(geometry=gap_polygons_proj, crs="EPSG:32734")
    gdf_latlng = gdf.to_crs(epsg=4326)
    return list(gdf_latlng.geometry)


def create_missing_tree_polygons(
    missing_coords: list[dict],
    placeholder_area_m2: float = 1.0,
    epsg_metric: int = 32734,
) -> list:
    def buffer_radius(area):
        return math.sqrt(area / math.pi)

    # Create Point geometries from dicts: Point(longitude, latitude)
    df = gpd.GeoDataFrame(
        geometry=[Point(coord["lng"], coord["lat"]) for coord in missing_coords],
        crs="EPSG:4326",
    )
    df_metric = df.to_crs(epsg=epsg_metric)

    radius = buffer_radius(placeholder_area_m2)
    df_metric["geometry"] = df_metric["geometry"].buffer(radius)

    df_latlng = df_metric.to_crs("EPSG:4326")
    return list(df_latlng.geometry)

def find_missing_tree_positions(tree_data: list[dict], 
                                outer_polygon,
                                epsg_metric: int = 32734,
                                tree_spacing: float = 4.0) -> dict:
    
    tree_df = pd.DataFrame(tree_data)
    tree_gdf = gpd.GeoDataFrame(tree_df,
                                geometry=gpd.points_from_xy(tree_df["lng"], tree_df["lat"]),
                                crs="EPSG:4326")
    
    print(f"Total input trees: {len(tree_gdf)}")
    
    tree_gdf_proj = tree_gdf.to_crs(epsg=epsg_metric)
    outer_proj = gpd.GeoSeries([outer_polygon], crs="EPSG:4326").to_crs(epsg=epsg_metric).iloc[0]
    
    missing_positions = find_gaps_in_orchard(tree_gdf_proj, outer_proj, tree_spacing)
    
    print(f"Found {len(missing_positions)} potential missing tree positions")
    
    return format_results(tree_gdf_proj, missing_positions, epsg_metric)

def create_custom_buffer(polygon, normal_buffer, bottom_buffer, left_buffer):
    """Create a custom inward buffer with larger buffers on bottom and left edges"""
    minx, miny, maxx, maxy = polygon.bounds
    
    # Get exterior coordinates
    exterior_coords = list(polygon.exterior.coords)
    buffered_coords = []
    
    # Calculate tolerances for edge detection
    width = maxx - minx
    height = maxy - miny
    horizontal_tolerance = width * 0.1   # 10% of width
    vertical_tolerance = height * 0.1    # 10% of height
    
    for i, (x, y) in enumerate(exterior_coords[:-1]):  # Skip last point (duplicate of first)
        # Determine which edge this point belongs to
        is_bottom = y <= (miny + vertical_tolerance)
        is_left = x <= (minx + horizontal_tolerance)
        is_top = y >= (maxy - vertical_tolerance)
        is_right = x >= (maxx - horizontal_tolerance)
        
        # Calculate inward movement based on edge
        if is_bottom and is_left:
            # Corner: apply both buffers
            buffered_coords.append((x + left_buffer, y + bottom_buffer))
        elif is_bottom:
            # Bottom edge: move up
            buffered_coords.append((x, y + bottom_buffer))
        elif is_left:
            # Left edge: move right
            buffered_coords.append((x + left_buffer, y))
        else:
            # Top or right edges: use normal buffer toward center
            center_x = minx + width / 2
            center_y = miny + height / 2
            
            # Move toward center by normal_buffer distance
            to_center_x = center_x - x
            to_center_y = center_y - y
            distance = np.sqrt(to_center_x**2 + to_center_y**2)
            
            if distance > 0:
                norm_x = to_center_x / distance
                norm_y = to_center_y / distance
                buffered_coords.append((x + norm_x * normal_buffer, y + norm_y * normal_buffer))
            else:
                buffered_coords.append((x, y))
    
    # Close the polygon
    buffered_coords.append(buffered_coords[0])
    
    try:
        return Polygon(buffered_coords)
    except:
        # Fallback to simple buffer if custom buffer fails
        return polygon.buffer(-normal_buffer)

def find_gaps_in_orchard(existing_trees, outer_polygon, spacing=4.0):    
    existing_coords = [(pt.x, pt.y) for pt in existing_trees.geometry]
    existing_points = np.array(existing_coords)
    minx, miny, maxx, maxy = outer_polygon.bounds
    
    # Create buffer zones around existing trees to prevent overlap
    tree_radius = spacing * 0.4  # Tree canopy radius (adjust based on tree type)
    existing_tree_buffers = [Point(x, y).buffer(tree_radius) for x, y in existing_coords]
    
    grid_spacing = spacing * 0.75  # Adjusted for better detection accuracy
    
    x_coords = np.arange(minx, maxx + grid_spacing, grid_spacing)
    y_coords = np.arange(miny, maxy + grid_spacing, grid_spacing)
    
    potential_positions = []
    
    for y in y_coords:
        for x in x_coords:
            test_point = Point(x, y)
            
            # Only consider points inside the orchard boundary
            if not outer_polygon.contains(test_point):
                continue
            
            # Check if this position overlaps with any existing tree
            overlaps_existing = any(buffer.contains(test_point) for buffer in existing_tree_buffers)
            if overlaps_existing:
                continue
                
            # Check distances to existing trees
            distances_to_existing = np.sqrt((existing_points[:, 0] - x)**2 + 
                                          (existing_points[:, 1] - y)**2)
            
            min_distance = np.min(distances_to_existing)
            
            # Position is a candidate if:
            # 1. It's far enough from existing trees to suggest a gap
            # 2. But not so far that it's outside the planting pattern
            min_threshold = spacing * 0.8  # Minimum distance to consider a gap
            max_threshold = spacing * 2.5  # Maximum distance to still be part of orchard
            
            if min_threshold < min_distance < max_threshold:
                # Additional check: ensure we're not too close to multiple trees
                nearby_trees = np.sum(distances_to_existing < spacing * 1.5)
                
                # If surrounded by too many trees, likely not a missing spot
                if nearby_trees < 4:  # Adjust based on planting pattern
                    potential_positions.append({
                        'geometry': test_point,
                        'x': x,
                        'y': y,
                        'distance_to_nearest': min_distance,
                        'nearby_tree_count': nearby_trees
                    })
    
    # Filter out positions too close to orchard edges with custom buffers
    normal_buffer_distance = spacing * 2  # Normal buffer for right and top
    bottom_buffer_distance = spacing * 3.5 # Larger buffer for bottom
    left_buffer_distance = spacing * 3.0    # Larger buffer for left
    
    # Create custom buffered boundary
    minx, miny, maxx, maxy = outer_polygon.bounds
    
    # Create a polygon with different buffer distances
    from shapely.geometry import Polygon
    
    # Get the original boundary coordinates
    exterior_coords = list(outer_polygon.exterior.coords)
    
    # Create inward-buffered boundary with custom buffers
    inner_boundary = create_custom_buffer(outer_polygon, normal_buffer_distance, bottom_buffer_distance, left_buffer_distance)
    
    filtered_positions = []
    for pos in potential_positions:
        if inner_boundary.contains(pos['geometry']):
            # Final overlap check with a smaller buffer for precision
            final_check_radius = tree_radius * 0.8
            test_buffer = pos['geometry'].buffer(final_check_radius)
            
            # Ensure no overlap with existing tree positions
            no_final_overlap = not any(
                test_buffer.intersects(Point(x, y).buffer(tree_radius * 0.5)) 
                for x, y in existing_coords
            )
            
            if no_final_overlap:
                filtered_positions.append(pos)
    
    return filtered_positions

def format_results(existing_trees, missing_positions, epsg_metric):    
    # Convert existing trees back to WGS84
    existing_coords = []
    for idx, tree in existing_trees.iterrows():
        point_wgs = gpd.GeoSeries([tree.geometry], crs=epsg_metric).to_crs("EPSG:4326").iloc[0]
        existing_coords.append({
            "lat": point_wgs.y,
            "lng": point_wgs.x,
            "id": idx
        })
    
    missing_coords = []
    for idx, pos in enumerate(missing_positions):
        point_wgs = gpd.GeoSeries([pos['geometry']], crs=epsg_metric).to_crs("EPSG:4326").iloc[0]
        
        # Enhanced confidence calculation
        distance = pos['distance_to_nearest']
        nearby_count = pos.get('nearby_tree_count', 0)
        
        # Factor in both distance and surrounding tree density
        if distance > 8.0 and nearby_count <= 1:
            confidence = "high"
        elif distance > 6.0 and nearby_count <= 2:
            confidence = "medium"
        elif distance > 4.5 and nearby_count <= 3:
            confidence = "low"
        else:
            confidence = "very_low"
        
        missing_coords.append({
            "lat": point_wgs.y,
            "lng": point_wgs.x,
            "confidence": confidence,
            "distance_to_nearest": round(distance, 1),
            "nearby_tree_count": nearby_count
        })
    
    # Filter out very low confidence results
    missing_coords = [m for m in missing_coords if m["confidence"] != "very_low"]
    
    return {
        "missing_coords": missing_coords,
        "existing_tree_coords": existing_coords,
        "summary": {
            "total_existing": len(existing_coords),
            "total_missing": len(missing_coords),
            "high_confidence": len([m for m in missing_coords if m["confidence"] == "high"]),
            "medium_confidence": len([m for m in missing_coords if m["confidence"] == "medium"]),
            "low_confidence": len([m for m in missing_coords if m["confidence"] == "low"])
        }
    }